// ======================================================================
// \title  ChoiceSlurrySerializableAc.cpp
// \author Generated by fpp-to-cpp
// \brief  cpp file for ChoiceSlurry struct
// ======================================================================

#include "cstdio"
#include "cstring"

#include "Fw/Types/Assert.hpp"
#include "Fw/Types/StringUtils.hpp"
#include "Ref/TypeDemo/ChoiceSlurrySerializableAc.hpp"

namespace Ref {

  // ----------------------------------------------------------------------
  // Constructors
  // ----------------------------------------------------------------------

  ChoiceSlurry ::
    ChoiceSlurry() :
      Serializable(),
      tooManyChoices(Ref::TooManyChoices(Ref::ManyChoices(Ref::Choice::ONE, Ref::Choice::ONE), Ref::ManyChoices(Ref::Choice::ONE, Ref::Choice::ONE))),
      separateChoice(Ref::Choice::ONE),
      choicePair(Ref::Choice::ONE, Ref::Choice::ONE)
  {

  }

  ChoiceSlurry ::
    ChoiceSlurry(
        const Ref::TooManyChoices& tooManyChoices,
        Ref::Choice::T separateChoice,
        const Ref::ChoicePair& choicePair
    ) :
      Serializable(),
      tooManyChoices(tooManyChoices),
      separateChoice(separateChoice),
      choicePair(choicePair)
  {

  }

  ChoiceSlurry ::
    ChoiceSlurry(const ChoiceSlurry& obj) :
      Serializable(),
      tooManyChoices(obj.tooManyChoices),
      separateChoice(obj.separateChoice),
      choicePair(obj.choicePair)
  {

  }

  // ----------------------------------------------------------------------
  // Operators
  // ----------------------------------------------------------------------

  ChoiceSlurry& ChoiceSlurry ::
    operator=(const ChoiceSlurry& obj)
  {
    if (this == &obj) {
      return *this;
    }

    set(obj.tooManyChoices, obj.separateChoice, obj.choicePair);
    return *this;
  }

  bool ChoiceSlurry ::
    operator==(const ChoiceSlurry& obj) const
  {
    return (
      (this->tooManyChoices == obj.tooManyChoices) &&
      (this->separateChoice == obj.separateChoice) &&
      (this->choicePair == obj.choicePair)
    );
  }

  bool ChoiceSlurry ::
    operator!=(const ChoiceSlurry& obj) const
  {
    return !(*this == obj);
  }

#ifdef BUILD_UT

  std::ostream& operator<<(std::ostream& os, const ChoiceSlurry& obj) {
    Fw::String s;
    obj.toString(s);
    os << s.toChar();
    return os;
  }

#endif

  // ----------------------------------------------------------------------
  // Member functions
  // ----------------------------------------------------------------------

  Fw::SerializeStatus ChoiceSlurry ::
    serialize(Fw::SerializeBufferBase& buffer) const
  {
    Fw::SerializeStatus status;

    status = buffer.serialize(this->tooManyChoices);
    if (status != Fw::FW_SERIALIZE_OK) {
      return status;
    }
    status = buffer.serialize(this->separateChoice);
    if (status != Fw::FW_SERIALIZE_OK) {
      return status;
    }
    status = buffer.serialize(this->choicePair);
    if (status != Fw::FW_SERIALIZE_OK) {
      return status;
    }

    return status;
  }

  Fw::SerializeStatus ChoiceSlurry ::
    deserialize(Fw::SerializeBufferBase& buffer)
  {
    Fw::SerializeStatus status;

    status = buffer.deserialize(this->tooManyChoices);
    if (status != Fw::FW_SERIALIZE_OK) {
      return status;
    }
    status = buffer.deserialize(this->separateChoice);
    if (status != Fw::FW_SERIALIZE_OK) {
      return status;
    }
    status = buffer.deserialize(this->choicePair);
    if (status != Fw::FW_SERIALIZE_OK) {
      return status;
    }

    return status;
  }

#if FW_SERIALIZABLE_TO_STRING || BUILD_UT

  void ChoiceSlurry ::
    toString(Fw::StringBase& sb) const
  {
    static const char* formatString =
      "( "
      "tooManyChoices = %s, "
      "separateChoice = %s, "
      "choicePair = %s"
      " )";

    // Declare strings to hold any serializable toString() arguments
    Fw::String tooManyChoicesStr;
    Fw::String separateChoiceStr;
    Fw::String choicePairStr;

    // Call toString for arrays and serializable types
    this->tooManyChoices.toString(tooManyChoicesStr);
    this->separateChoice.toString(separateChoiceStr);
    this->choicePair.toString(choicePairStr);

    char outputString[FW_SERIALIZABLE_TO_STRING_BUFFER_SIZE];
    (void) snprintf(
      outputString,
      FW_SERIALIZABLE_TO_STRING_BUFFER_SIZE,
      formatString,
      tooManyChoicesStr.toChar(),
      separateChoiceStr.toChar(),
      choicePairStr.toChar()
    );

    outputString[FW_SERIALIZABLE_TO_STRING_BUFFER_SIZE-1] = 0; // NULL terminate
    sb = outputString;
  }

#endif

  // ----------------------------------------------------------------------
  // Setter functions
  // ----------------------------------------------------------------------

  void ChoiceSlurry ::
    set(
        const Ref::TooManyChoices& tooManyChoices,
        Ref::Choice::T separateChoice,
        const Ref::ChoicePair& choicePair
    )
  {
    this->tooManyChoices = tooManyChoices;
    this->separateChoice = separateChoice;
    this->choicePair = choicePair;
  }

  void ChoiceSlurry ::
    settooManyChoices(const Ref::TooManyChoices& tooManyChoices)
  {
    this->tooManyChoices = tooManyChoices;
  }

  void ChoiceSlurry ::
    setseparateChoice(Ref::Choice::T separateChoice)
  {
    this->separateChoice = separateChoice;
  }

  void ChoiceSlurry ::
    setchoicePair(const Ref::ChoicePair& choicePair)
  {
    this->choicePair = choicePair;
  }

}
