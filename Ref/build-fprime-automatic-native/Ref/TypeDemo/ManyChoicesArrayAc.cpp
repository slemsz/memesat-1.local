// ======================================================================
// \title  ManyChoicesArrayAc.cpp
// \author Generated by fpp-to-cpp
// \brief  cpp file for ManyChoices array
// ======================================================================

#include <cstdio>
#include <cstring>

#include "Fw/Types/Assert.hpp"
#include "Fw/Types/StringUtils.hpp"
#include "Ref/TypeDemo/ManyChoicesArrayAc.hpp"

namespace Ref {

  // ----------------------------------------------------------------------
  // Constructors
  // ----------------------------------------------------------------------

  ManyChoices ::
    ManyChoices() :
      Serializable()
  {
    // Construct using element-wise constructor
    *this = ManyChoices(
      Ref::Choice::ONE,
      Ref::Choice::ONE
    );
  }

  ManyChoices ::
    ManyChoices(const ElementType (&a)[SIZE]) :
      Serializable()
  {
    for (U32 index = 0; index < SIZE; index++) {
      this->elements[index] = a[index];
    }
  }

  ManyChoices ::
    ManyChoices(const ElementType& e) :
      Serializable()
  {
    for (U32 index = 0; index < SIZE; index++) {
      this->elements[index] = e;
    }
  }

  ManyChoices ::
    ManyChoices(
        const ElementType& e1,
        const ElementType& e2
    ) :
      Serializable()
  {
    this->elements[0] = e1;
    this->elements[1] = e2;
  }

  ManyChoices ::
    ManyChoices(const ManyChoices& obj) :
      Serializable()
  {
    for (U32 index = 0; index < SIZE; index++) {
      this->elements[index] = obj.elements[index];
    }
  }

  // ----------------------------------------------------------------------
  // Operators
  // ----------------------------------------------------------------------

  ManyChoices::ElementType& ManyChoices ::
    operator[](const U32 i)
  {
    FW_ASSERT(i < SIZE);
    return this->elements[i];
  }

  const ManyChoices::ElementType& ManyChoices ::
    operator[](const U32 i) const
  {
    FW_ASSERT(i < SIZE);
    return this->elements[i];
  }

  ManyChoices& ManyChoices ::
    operator=(const ManyChoices& obj)
  {
    if (this == &obj) {
      return *this;
    }

    for (U32 index = 0; index < SIZE; index++) {
      this->elements[index] = obj.elements[index];
    }
    return *this;
  }

  ManyChoices& ManyChoices ::
    operator=(const ElementType (&a)[SIZE])
  {
    for (U32 index = 0; index < SIZE; index++) {
      this->elements[index] = a[index];
    }
    return *this;
  }

  ManyChoices& ManyChoices ::
    operator=(const ElementType& e)
  {
    for (U32 index = 0; index < SIZE; index++) {
      this->elements[index] = e;
    }
    return *this;
  }

  bool ManyChoices ::
    operator==(const ManyChoices& obj) const
  {
    for (U32 index = 0; index < SIZE; index++) {
      if (!((*this)[index] == obj[index])) {
        return false;
      }
    }
    return true;
  }

  bool ManyChoices ::
    operator!=(const ManyChoices& obj) const
  {
    return !(*this == obj);
  }

#ifdef BUILD_UT

  std::ostream& operator<<(std::ostream& os, const ManyChoices& obj) {
    Fw::String s;
    obj.toString(s);
    os << s;
    return os;
  }

#endif

  // ----------------------------------------------------------------------
  // Member functions
  // ----------------------------------------------------------------------

  Fw::SerializeStatus ManyChoices ::
    serialize(Fw::SerializeBufferBase& buffer) const
  {
    Fw::SerializeStatus status = Fw::FW_SERIALIZE_OK;
    for (U32 index = 0; index < SIZE; index++) {
      status = buffer.serialize((*this)[index]);
      if (status != Fw::FW_SERIALIZE_OK) {
        return status;
      }
    }
    return status;
  }

  Fw::SerializeStatus ManyChoices ::
    deserialize(Fw::SerializeBufferBase& buffer)
  {
    Fw::SerializeStatus status = Fw::FW_SERIALIZE_OK;
    for (U32 index = 0; index < SIZE; index++) {
      status = buffer.deserialize((*this)[index]);
      if (status != Fw::FW_SERIALIZE_OK) {
        return status;
      }
    }
    return status;
  }

#if FW_ARRAY_TO_STRING

  void ManyChoices ::
    toString(Fw::StringBase& sb) const
  {
    static const char *formatString = "[ "
      "%s "
      "%s ]";

    // Declare strings to hold any serializable toString() arguments
    Fw::String str0;
    Fw::String str1;

    // Call toString for arrays and serializable types
    this->elements[0].toString(str0);
    this->elements[1].toString(str1);

    char outputString[FW_ARRAY_TO_STRING_BUFFER_SIZE];
    (void) snprintf(
      outputString,
      FW_ARRAY_TO_STRING_BUFFER_SIZE,
      formatString,
      str0.toChar(),
      str1.toChar()
    );

    outputString[FW_ARRAY_TO_STRING_BUFFER_SIZE-1] = 0; // NULL terminate
    sb = outputString;
  }

#endif

}
